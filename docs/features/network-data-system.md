# Network Data System

The Half-Life Unified SDK provides a system for transferring large amounts of immutable data from the server to the client.

This works by generating a file called `networkdata/data.json` containing structured data in JSON form generated by various game systems when a map is loaded.

This file is precached so players download the file when they connect to the server. The client then loads the file to initialize various game systems on the client side.

The client deletes its local copy of the file prior to downloading the new one to ensure that it always has the right file.

If the system encounters an error while generating the data it will be shut down. If the client encounters an error while deserializing the data it will return the player to the main menu.

In either case the error message is printed in the console.

The engine is capable of uploading files up to the size specified by the `sv_filetransfermaxsize` cvar, which defaults to **10 MiB**, or **10485760 bytes**. The average file size for an unmodified Unified SDK is about **100 KiB**, with most of the space being taken up by the sentences list.

Project information is sent along and is used to verify that the client and server are compatible with each-other. Incompatible clients will automatically disconnect from the server to prevent further problems from occurring.

Alpha builds disable the compatibility check to avoid complicating development.

The **NetworkDataProtocolVersion** constant should be incremented whenever the structure of the data in the file changes to allow the system to detect compatibility issues early on.

To ensure the correct operation of this system the following cvars are forcibly turned on:
* sv_allowdownload
* sv_send_resources
* sv_allow_dlfile
* cl_allowdownload

Two limitations currently exist:
1. You cannot connect to a dedicated server running from the same game installation as the client. This should never be a problem because the dedicated server tool distributed with the client does not work anymore, and dedicated servers should always be installed separately through SteamCMD.
2. If multiple servers share a FastDL server and transfer the generated file to it they will conflict and use the wrong file. If this does become a problem then a possible solution is to store the file in a subdirectory named after the server IP and port: `1.2.3.4_port`. This would make the filename unique for each server. The client has the server's IP address so this should work, but whether this will actually work or not remains to be seen.

The network data system uses the logger named `net_data`.

## Sending and receiving data

To send and receive data for a particular game system a class must implement the `INetworkDataBlockHandler` interface:
```cpp
class AmmoTypeSystem final : public IGameSystem, public INetworkDataBlockHandler
{
public:
	bool Initialize() override;
	void HandleNetworkDataBlock(NetworkDataBlock& block) override;

	// Remainder of class...
};
```

And register itself as a block handler:
```cpp
bool AmmoTypeSystem::Initialize()
{
	g_NetworkData.RegisterHandler("AmmoTypes", this);
	return true;
}
```

The handler must provide the logic for serializing and deserializing the same data:
```cpp
void AmmoTypeSystem::HandleNetworkDataBlock(NetworkDataBlock& block)
{
	if (block.Mode == NetworkDataMode::Serialize)
	{
		block.Data = json::array();

		for (const auto& type : m_AmmoTypes)
		{
			json data = json::object();

			data.emplace("Name", type.Name.c_str());
			data.emplace("MaximumCapacity", type.MaximumCapacity);

			if (!type.WeaponName.empty())
			{
				data.emplace("WeaponName", type.WeaponName.c_str());
			}

			block.Data.push_back(std::move(data));
		}
	}
	else
	{
		Clear();

		for (const auto& data : block.Data)
		{
			const auto name = data.value("Name", "");
			const int maximumCapacity = data.value("MaximumCapacity", -2);
			const auto weaponName = data.value("WeaponName", "");

			if (Register(name, maximumCapacity, weaponName) == -1)
			{
				block.ErrorMessage = "Invalid ammo type received from server";
				return;
			}
		}
	}
}
```

Setting `block.ErrorMessage` to a non-empty string aborts serialization/deserialization.

Any kind of JSON data type is supported, but it is recommended to keep it as simple as possible to reduce the size of the generated file.
